bthread_id is a special synchronization structure, which can mutually exclusive different links in the RPC process, and can also find the RPC context (ie Controller) in O(1) time. Note that here we are talking about bthread_id_t, not bthread_t (bthread's tid), this name is indeed not very good and easy to confuse.

Specifically, the problems solved by bthread_id are:

-The response came back during the process of sending the RPC, and the response code competed with the sending code.
-The timer is triggered soon after setting the timer, and the timeout processing code and the sending code compete.
-Retry the competition generated by multiple responses coming back at the same time.
-Find the corresponding RPC context in O(1) time through correlation_id, without building a global hash table from correlation_id to RPC context.
-Cancel RPC.

The bugs mentioned above are widespread in other rpc frameworks. Let's take a look at how brpc solves these problems through bthread_id.

bthread_id consists of two parts, one is the 64-bit id visible to the user, and the other is the corresponding invisible bthread::Id structure. User interfaces are all operations id. The way of mapping from id to structure is similar to [other structure] (memory_management.md) in brpc: 32-bit is the displacement of the memory pool, and 32-bit is the version. The former is O(1) time positioning, and the latter prevents ABA problems.

The interface of bthread_id is not very concise, there are many APIs:

- create
- lock
- unlock
- unlock_and_destroy
- join
- error

So many interfaces are to satisfy different usage processes.

- 发送request的流程：bthread_id_create -> bthread_id_lock -> ... register timer and send RPC ... -> bthread_id_unlock
  -The process of receiving the response: bthread_id_lock -> ..process response -> bthread_id_unlock_and_destroy
  -Exception handling process: timeout/socket fail -> bthread_id_error -> execute on_error callback (locked here), there are two cases
  -Request retry/backup request: Re-register timer and send RPC -> bthread_id_unlock
  -Unable to retry, eventually failed: bthread_id_unlock_and_destroy
  -Synchronously waiting for the RPC to end: bthread_id_join

In order to reduce waiting, bthread_id has made some optimized mechanisms:

-When an error occurs, if the bthread_id is locked, the error information will be placed in a pending queue, and the bthread_id_error function will return immediately. When bthread_id_unlock, if there is a task in the pending queue, it will be taken out and executed.
-At the end of the RPC, if there is a user callback, first execute a bthread_id_about_to_destroy to make the waiting bthread_id_lock operation fail immediately, then execute the user callback (this may take a long time and cannot be controlled), and finally execute bthread_id_unlock_and_destroy